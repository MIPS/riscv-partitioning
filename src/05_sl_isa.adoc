:imagesdir: ./images

[[slISA]]
== "Security Levels" ISA extension set

=== Preamble

* The World-ID extension set is augmented;
** Addition of `mwidseclist` and its behavior. (See "Security Level definition"
   below in <<mwidseclist>>.)
** Enforcement of sane relationships between the Security Levels of the (WIDs
   associated with the) 3 hart privilege levels. (See "Security Level
   constraints" below in <<slConstraints>>).

[[mwidseclist]]
=== Security Level definition

==== `NLevels`

There are `NLevels` distinct security levels available to the SoC, which has an
upper-limit of 16 (thus requiring at most 4-bits to encode a security level).
The Security Levels extension adds the `mwidseclist0`-`mwidseclist3` CSRs,
which pack 4 bits of Security Level per WID, for up to `XLEN` WIDs.

==== Locking

It is important to note that the `mwidseclistX` CSRs are lockable, they are
locked conjointly with `mwid` and `mwidlist` whenever the former's `L` bit is
set. See <<lockablePartitioning>> for more detail.

==== Values

With `NLevels` being configurable, the range of SLs will vary from `0` to
`NLevels-1`. For improved generality, we will assume that an SL of `0` is the
highest security level, down to `NLevels-1` being the lowest. We have carefully
used words such as 'superior' and 'inferior' when referring to SLs, precisely
so that we avoid using words such as 'greater' or 'lower', here then is the
reason:

****
A superior SL is one with a lower value, and conversely an inferior SL is one
with a higher value. The value of the highest SL is zero.
****

[[slConstraints]]
=== Security Level constraints

A run-time privilege constraint is defined that mimics the behavior expected of
TEE-like software models, namely a lower privilege level cannot be more secure
the privilege levels above it. In RISC-V terms, and bearing in mind that a
'higher privilege level' corresponds to a lower SL _value_;

....
    SecurityLevel(M-mode) <= SecurityLevel(HS-mode)
    SecurityLevel(HS-mode) <= SecurityLevel(LS-mode)
    SecurityLevel(HS-mode) <= SecurityLevel(HU-mode)
    SecurityLevel(VS-mode) <= SecurityLevel(VU-mode)
....

=== Decision logic

The following subsections show the additional constraints for determining
whether to accept or reject a load/store/fetch transaction. See
<<decisionLogic>> for more information on how rejections are handled.

==== Effective Security Level

* The security level of a privilege mode is determined by using that privilege
  level's WID as an index into the `mwidseclistX` registers. Zero is an
  appropriate default for parts that require no Security Level support.
* The "effective security level" is the security level of the current privilege
  level.

==== Privilege constraints

These checks implement the "run-time privilege constraint" described in
<<slConstraints>>.

* If the hart is in (H)S-mode and the security level of (H)S-mode is superior
  to the security level of M-mode, reject transaction.
* If the hart is in VS-mode and the security level of VS-mode is superior to
  the security level of HS-mode, reject transaction.
* If the hart is in (H)U-mode and the security level of U-mode is superior to
  the security level of (H)S-mode, reject transaction.
* If the hart is in VU-mode and the security level of VS-mode is superior to
  the security level of HS-mode, reject transaction.

It should be noted that, semantically, a privilege constraint fails on the
first instruction fetch after the `xRET` instruction, even if the
implementation detects the anomalous condition earlier than that. Similarly,
after the fault, the values in `xstatus/xcause/`[...] will reflect the
instruction address and privilege mode targetted by the `xRET` instruction.

[[slRegisterMap]]
=== Register map addition

==== Summary

[%header,cols="2,2,2,2,3"]
|===
| Register | Access | Proposed offset | Suggested default | Description
| `mwidseclist0` | RW for M until locked | ??? | `0x0` | Security Level of WIDs
| `mwidseclist1` | RW for M until locked | ??? | `0x0` | Security Level of WIDs
| `mwidseclist2` | RW for M until locked | ??? | `0x0` | Security Level of WIDs
| `mwidseclist3` | RW for M until locked | ??? | `0x0` | Security Level of WIDs
|===

==== `mwidseclist0`: Security Level of WIDs

[%header,cols="1,2,5"]
|===
| Name | Bits | Description
| slY | `[XLEN-1]:[XLEN-4]` | `Y=(XLEN/4)-1`. Security Level for WID `Y`
| ... | ... | ...
| sl1 | `7:4` | Security Level for WID `1`
| sl0 | `3:0` | Security Level for WID `0`
|===

The `mwidseclist1`, `mwidseclist2`, and `mwidseclist3` registers are of
identical structure, but they deal with correspondingly higher-order WIDs, up
to `XLEN-1` inclusive.

These registers are locked if and only if the `mwid` register is. The
`mwidseclistX` CSRs ignore writes when locked by `mwid`. CSR writes to
`mwidseclist` and `mwid` are ordered by the hardware in the same manner as
writes to ePMP registers.  When necessary, software can enforce a specific
ordering between a CSR write and other instructions with an appropriate FENCE.

Only the registers (and bits thereof) that are required are implemented. For
WIDs greater than or equal to `NWorlds`, the (remaining) bits are read-only
zero.

